"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[77874],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return h}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),h=a,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||i;return t?r.createElement(m,o(o({ref:n},p),{},{components:t})):r.createElement(m,o({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},75307:function(e,n,t){t.r(n),t.d(n,{assets:function(){return v},contentTitle:function(){return h},default:function(){return y},frontMatter:function(){return d},metadata:function(){return m},toc:function(){return f}});var r=t(3905),a=Object.defineProperty,i=Object.defineProperties,o=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,p=(e,n,t)=>n in e?a(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,u=(e,n)=>{for(var t in n||(n={}))s.call(n,t)&&p(e,t,n[t]);if(l)for(var t of l(n))c.call(n,t)&&p(e,t,n[t]);return e};const d={},h="Services",m={unversionedId:"manual/development/services",id:"manual/development/services",title:"Services",description:'Every App needs to be exposed to something, either an UI, API or other containers.However with Kubernetes we don\'t directly connect to the containers running the App, because those might be on another node or there might be multiple "high available" containers for the App. Instead we use what is called Services. Services are simply put "Internal Load-Balancers", they also guaranteed to be reachable by (internal!) DNS name and (in some cases) prevent traffic from reaching your App when the healthcheck isn\'t finished yet (or is failing).',source:"@site/docs/manual/development/services.md",sourceDirName:"manual/development",slug:"/manual/development/services",permalink:"/docs/manual/development/services",draft:!1,editUrl:"https://github.com/truecharts/website/tree/master/docs/manual/development/services.md",tags:[],version:"current",frontMatter:{},sidebar:"manualSidebar",previous:{title:"Questions.yaml",permalink:"/docs/manual/development/questions-yaml"},next:{title:"Storage",permalink:"/docs/manual/development/storage"}},v={},f=[{value:"Two kinds of services",id:"two-kinds-of-services",level:2},{value:"Main Service",id:"main-service",level:3}],b={toc:f};function y(e){var n,t=e,{components:a}=t,p=((e,n)=>{var t={};for(var r in e)s.call(e,r)&&n.indexOf(r)<0&&(t[r]=e[r]);if(null!=e&&l)for(var r of l(e))n.indexOf(r)<0&&c.call(e,r)&&(t[r]=e[r]);return t})(t,["components"]);return(0,r.kt)("wrapper",(n=u(u({},b),p),i(n,o({components:a,mdxType:"MDXLayout"}))),(0,r.kt)("h1",u({},{id:"services"}),"Services"),(0,r.kt)("p",null,'Every App needs to be exposed to something, either an UI, API or other containers.However with Kubernetes we don\'t directly connect to the containers running the App, because those might be on another node or there might be multiple "high available" containers for the App. Instead we use what is called ',(0,r.kt)("inlineCode",{parentName:"p"},"Services"),'. Services are simply put "Internal Load-Balancers", they also guaranteed to be reachable by (internal!) DNS name and (in some cases) prevent traffic from reaching your App when the healthcheck isn\'t finished yet (or is failing).'),(0,r.kt)("h2",u({},{id:"two-kinds-of-services"}),"Two kinds of services"),(0,r.kt)("h3",u({},{id:"main-service"}),"Main Service"),(0,r.kt)("p",null,"Every App is required to have a main service, the primary thing that users (or other Apps!) connect with. No mater if it's a webUI, an API, a database connection or something totally else, A service is always required."),(0,r.kt)("p",null,"Please keep in mind that every App is different, some just have one service (which ",(0,r.kt)("em",{parentName:"p"},"ALWAYS")," has to be called ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),") and others need more (which each has to have an unique name). Every App also uses different ports, so please alter accordingly."),(0,r.kt)("pre",null,(0,r.kt)("code",u({parentName:"pre"},{className:"language-yaml"}),'  - variable: service\n    group: "Networking"\n    label: "Configure Service(s)"\n    schema:\n      type: dict\n      attrs:\n        - variable: main\n          label: "Main Service"\n          description: "The Primary service on which the healthcheck runs, often the webUI"\n          schema:\n            type: dict\n            attrs:\n              - variable: enabled\n                label: "Enable the service"\n                schema:\n                  type: boolean\n                  default: true\n                  hidden: true\n              - variable: type\n                label: "Service Type"\n                description: "ClusterIP\'s are only internally available, nodePorts expose the container to the host node System, Loadbalancer exposes the service using the system loadbalancer"\n                schema:\n                  type: string\n                  default: "NodePort"\n                  enum:\n                    - value: "NodePort"\n                      description: "NodePort"\n                    - value: "ClusterIP"\n                      description: "ClusterIP"\n                    - value: "LoadBalancer"\n                      description: "LoadBalancer"\n              - variable: loadBalancerIP\n                label: "LoadBalancer IP"\n                description: "LoadBalancerIP"\n                schema:\n                  show_if: [["type", "=", "LoadBalancer"]]\n                  type: string\n                  default: ""\n                  required: true\n              - variable: externalIPs\n                label: "External IP\'s"\n                description: "External IP\'s"\n                schema:\n                  show_if: [["type", "=", "LoadBalancer"]]\n                  type: list\n                  default: []\n                  items:\n                    - variable: externalIP\n                      label: "External IP"\n                      required: true\n                      schema:\n                        type: string\n              - variable: ports\n                label: "Service\'s Port(s) Configuration"\n                schema:\n                  type: dict\n                  attrs:\n                    - variable: main\n                      label: "Main Service Port Configuration"\n                      schema:\n                        type: dict\n                        attrs:\n                          - variable: enabled\n                            label: "Enable the port"\n                            schema:\n                              type: boolean\n                              default: true\n                              hidden: true\n                          - variable: protocol\n                            label: "Port Type"\n                            schema:\n                              type: string\n                              default: "HTTP"\n                              hidden: false\n                              enum:\n                                - value: HTTP\n                                  description: "HTTP"\n                                - value: "HTTPS"\n                                  description: "HTTPS"\n                                - value: TCP\n                                  description: "TCP"\n                                - value: "UDP"\n                                  description: "UDP"\n                          - variable: port\n                            label: "Container Port"\n                            schema:\n                              type: int\n                              default: 5076\n                              editable: false\n                              hidden: true\n                          - variable: targetport\n                            label: "Target Port"\n                            description: "This port exposes the container port on the service"\n                            schema:\n                              type: int\n                              default: 5076\n                              editable: true\n                              hidden: false\n                              required: true\n                          - variable: nodePort\n                            label: "Node Port (Optional)"\n                            description: "This port gets exposed to the node. Only considered when service type is NodePort"\n                            schema:\n                              type: int\n                              min: 9000\n                              max: 65535\n                              default: 36041\n                              required: true\n')))}y.isMDXComponent=!0}}]);